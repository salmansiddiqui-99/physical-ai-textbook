"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics=globalThis.webpackChunkphysical_ai_humanoid_robotics||[]).push([[940],{3545:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"module2-simulation/ch1-gazebo-essentials","title":"Chapter 2.1: Gazebo Essentials for Humanoid Simulation","description":"Master Gazebo physics simulation for humanoid robots including world building, collision detection, and rigid body dynamics.","source":"@site/docs/module2-simulation/ch1-gazebo-essentials.md","sourceDirName":"module2-simulation","slug":"/module2-simulation/ch1-gazebo-essentials","permalink":"/physical-ai-textbook/docs/module2-simulation/ch1-gazebo-essentials","draft":false,"unlisted":false,"editUrl":"https://github.com/salmansiddiqui-99/physical-ai-textbook/tree/main/docs/module2-simulation/ch1-gazebo-essentials.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"id":"ch1-gazebo-essentials","title":"Chapter 2.1: Gazebo Essentials for Humanoid Simulation","sidebar_label":"Gazebo Essentials","sidebar_position":4,"description":"Master Gazebo physics simulation for humanoid robots including world building, collision detection, and rigid body dynamics.","keywords":["Gazebo","physics simulation","SDF","world files","collision detection","rigid body dynamics"],"prerequisites":["Module 1 completed (ROS 2 and URDF fundamentals)","Basic understanding of physics (gravity, friction, forces)","Linux terminal proficiency"],"learning_objectives":["Create and configure Gazebo simulation worlds","Spawn humanoid URDF models in Gazebo","Configure physics parameters for realistic humanoid behavior","Debug simulation issues using Gazebo tools"],"estimated_time":"100 minutes"},"sidebar":"tutorialSidebar","previous":{"title":"URDF for Humanoids","permalink":"/physical-ai-textbook/docs/module1-ros2/ch3-urdf-humanoids"},"next":{"title":"2.2 Sensor Simulation","permalink":"/physical-ai-textbook/docs/module2-simulation/ch2-sensor-simulation"}}');var s=i(4848),o=i(8453);const t={id:"ch1-gazebo-essentials",title:"Chapter 2.1: Gazebo Essentials for Humanoid Simulation",sidebar_label:"Gazebo Essentials",sidebar_position:4,description:"Master Gazebo physics simulation for humanoid robots including world building, collision detection, and rigid body dynamics.",keywords:["Gazebo","physics simulation","SDF","world files","collision detection","rigid body dynamics"],prerequisites:["Module 1 completed (ROS 2 and URDF fundamentals)","Basic understanding of physics (gravity, friction, forces)","Linux terminal proficiency"],learning_objectives:["Create and configure Gazebo simulation worlds","Spawn humanoid URDF models in Gazebo","Configure physics parameters for realistic humanoid behavior","Debug simulation issues using Gazebo tools"],estimated_time:"100 minutes"},l="Chapter 2.1 - Gazebo Essentials",c={},a=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Section 1: Gazebo Architecture and Setup",id:"section-1-gazebo-architecture-and-setup",level:2},{value:"Subsection 1.1: Gazebo Components",id:"subsection-11-gazebo-components",level:3},{value:"Subsection 1.2: Gazebo vs. Gazebo Classic",id:"subsection-12-gazebo-vs-gazebo-classic",level:3},{value:"Subsection 1.3: Verifying Installation",id:"subsection-13-verifying-installation",level:3},{value:"Section 2: Creating Your First World",id:"section-2-creating-your-first-world",level:2},{value:"Example: Simple World with Ground Plane",id:"example-simple-world-with-ground-plane",level:3},{value:"Section 3: Spawning Humanoid Robots",id:"section-3-spawning-humanoid-robots",level:2},{value:"Subsection 3.1: URDF to Gazebo",id:"subsection-31-urdf-to-gazebo",level:3},{value:"Example: Gazebo-Enhanced URDF",id:"example-gazebo-enhanced-urdf",level:3},{value:"Subsection 3.2: Spawning with ROS 2",id:"subsection-32-spawning-with-ros-2",level:3},{value:"Section 4: Physics Configuration",id:"section-4-physics-configuration",level:2},{value:"Subsection 4.1: Physics Engine Options",id:"subsection-41-physics-engine-options",level:3},{value:"Subsection 4.2: Contact Surface Properties",id:"subsection-42-contact-surface-properties",level:3},{value:"Section 5: Gazebo GUI Tools",id:"section-5-gazebo-gui-tools",level:2},{value:"Subsection 5.1: View Menu Tools",id:"subsection-51-view-menu-tools",level:3},{value:"Subsection 5.2: Useful Keyboard Shortcuts",id:"subsection-52-useful-keyboard-shortcuts",level:3},{value:"Subsection 5.3: Inspection Tools",id:"subsection-53-inspection-tools",level:3},{value:"Hands-On Project: Humanoid Drop Test",id:"hands-on-project-humanoid-drop-test",level:2},{value:"Step 1: Create Drop Test World",id:"step-1-create-drop-test-world",level:3},{value:"Step 2: Launch with Humanoid at 2m Height",id:"step-2-launch-with-humanoid-at-2m-height",level:3},{value:"Step 3: Monitor Impact Forces",id:"step-3-monitor-impact-forces",level:3},{value:"Challenge: Test Your Understanding",id:"challenge-test-your-understanding",level:2},{value:"Summary",id:"summary",level:2},{value:"Further Reading",id:"further-reading",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(n){const e={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"chapter-21---gazebo-essentials",children:"Chapter 2.1 - Gazebo Essentials"})}),"\n",(0,s.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Create Gazebo world files with custom environments for humanoid testing"}),"\n",(0,s.jsx)(e.li,{children:"Spawn and control URDF-based humanoid robots in simulation"}),"\n",(0,s.jsx)(e.li,{children:"Configure physics engines (gravity, friction, collision properties) for realistic behavior"}),"\n",(0,s.jsx)(e.li,{children:"Use Gazebo GUI tools and ROS 2 integration for robot debugging"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsx)(e.p,{children:"Before starting this chapter, you should:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["Have completed ",(0,s.jsx)(e.a,{href:"/physical-ai-textbook/docs/module1-ros2/ch1-ros2-basics",children:"Module 1"})," (ROS 2 and URDF)"]}),"\n",(0,s.jsx)(e.li,{children:"Understand basic physics concepts (forces, torque, center of mass)"}),"\n",(0,s.jsx)(e.li,{children:"Have Gazebo Classic or Gazebo Fortress installed with ROS 2 Humble"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Gazebo"})," is the industry-standard robot simulator used by researchers and companies worldwide\u2014from NASA's Mars rovers to Boston Dynamics' humanoid prototypes. Before deploying expensive hardware, engineers test algorithms in Gazebo's physics-accurate environment."]}),"\n",(0,s.jsx)(e.p,{children:"For humanoid robotics, simulation is critical because:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Safety"}),": Test falling, collision, and recovery behaviors without hardware damage"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Speed"}),": Iterate on control algorithms 10-100x faster than real-time"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Repeatability"}),": Reproduce exact scenarios for debugging and validation"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Cost"}),": Avoid wear-and-tear on mechanical components during development"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"In this chapter, you'll learn how to create simulation worlds, spawn your URDF humanoids from Module 1, configure physics properties, and integrate with ROS 2 for closed-loop control. By the end, you'll have a virtual humanoid laboratory for testing any control algorithm safely."}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"section-1-gazebo-architecture-and-setup",children:"Section 1: Gazebo Architecture and Setup"}),"\n",(0,s.jsx)(e.p,{children:"Gazebo consists of three main components that work together to simulate robots."}),"\n",(0,s.jsx)(e.h3,{id:"subsection-11-gazebo-components",children:"Subsection 1.1: Gazebo Components"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Gazebo Server (gzserver)"}),": Physics engine that runs the simulation"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Computes rigid body dynamics using ODE, Bullet, or DART"}),"\n",(0,s.jsx)(e.li,{children:"Handles collision detection and contact forces"}),"\n",(0,s.jsx)(e.li,{children:"Updates sensor data (cameras, LiDAR, IMU)"}),"\n",(0,s.jsx)(e.li,{children:"Publishes simulation state"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Gazebo Client (gzclient)"}),": 3D visualization GUI"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Renders robot models and environments"}),"\n",(0,s.jsx)(e.li,{children:"Provides interaction tools (move objects, measure distances)"}),"\n",(0,s.jsx)(e.li,{children:"Displays sensor visualizations"}),"\n",(0,s.jsx)(e.li,{children:"Can run separately from server (headless simulation)"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Gazebo Plugins"}),": Extend functionality"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Sensor plugins (camera, LiDAR, IMU)"}),"\n",(0,s.jsx)(e.li,{children:"Actuator plugins (joint motors, grippers)"}),"\n",(0,s.jsx)(e.li,{children:"World plugins (custom physics, logging)"}),"\n",(0,s.jsx)(e.li,{children:"ROS 2 integration (ros_gz_bridge)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"subsection-12-gazebo-vs-gazebo-classic",children:"Subsection 1.2: Gazebo vs. Gazebo Classic"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Feature"}),(0,s.jsx)(e.th,{children:"Gazebo Classic"}),(0,s.jsx)(e.th,{children:"Gazebo (Ignition/Fortress+)"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Physics Engines"})}),(0,s.jsx)(e.td,{children:"ODE, Bullet, Simbody"}),(0,s.jsx)(e.td,{children:"DART, TPE"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"File Format"})}),(0,s.jsx)(e.td,{children:"SDF 1.6-1.9"}),(0,s.jsx)(e.td,{children:"SDF 1.8+"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"ROS 2 Integration"})}),(0,s.jsx)(e.td,{children:"ros2_gazebo_ros_pkgs"}),(0,s.jsx)(e.td,{children:"ros_gz"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Performance"})}),(0,s.jsx)(e.td,{children:"Good"}),(0,s.jsx)(e.td,{children:"Better (multithreading)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Use Case"})}),(0,s.jsx)(e.td,{children:"ROS 2 Humble (default)"}),(0,s.jsx)(e.td,{children:"Newer distributions"})]})]})]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"For this course"}),": We use ",(0,s.jsx)(e.strong,{children:"Gazebo Classic"})," with ROS 2 Humble (most common setup)."]}),"\n",(0,s.jsx)(e.h3,{id:"subsection-13-verifying-installation",children:"Subsection 1.3: Verifying Installation"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Check Gazebo version\r\ngazebo --version\r\n\r\n# Launch empty Gazebo world\r\ngazebo\r\n\r\n# Launch with ROS 2 integration\r\nros2 launch gazebo_ros gazebo.launch.py\n"})}),"\n",(0,s.jsx)(e.p,{children:"Expected output: Gazebo GUI opens with an empty world (ground plane, sun lighting)."}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Key Terminology"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"SDF (Simulation Description Format)"}),": XML format for worlds and models"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"World"}),": Complete simulation environment (terrain, lighting, physics settings)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Model"}),": Individual entity (robot, obstacle, furniture)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Link"}),": Rigid body within a model (same as URDF)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Joint"}),": Connection between links (same as URDF)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Plugin"}),": Shared library that extends Gazebo functionality"]}),"\n"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"section-2-creating-your-first-world",children:"Section 2: Creating Your First World"}),"\n",(0,s.jsxs)(e.p,{children:["Gazebo worlds are defined in ",(0,s.jsx)(e.strong,{children:".world"})," files using SDF XML format."]}),"\n",(0,s.jsx)(e.h3,{id:"example-simple-world-with-ground-plane",children:"Example: Simple World with Ground Plane"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Purpose"}),": Create a minimal world for humanoid testing with proper lighting and physics."]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Code"})," (",(0,s.jsx)(e.code,{children:"simple_world.world"}),"):"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\r\n<sdf version="1.6">\r\n  <world name="humanoid_test_world">\r\n\r\n    \x3c!-- Physics settings --\x3e\r\n    <physics type="ode">\r\n      <max_step_size>0.001</max_step_size>\r\n      <real_time_factor>1</real_time_factor>\r\n      <real_time_update_rate>1000</real_time_update_rate>\r\n      <gravity>0 0 -9.81</gravity>\r\n    </physics>\r\n\r\n    \x3c!-- Ground plane --\x3e\r\n    <include>\r\n      <uri>model://ground_plane</uri>\r\n    </include>\r\n\r\n    \x3c!-- Sun lighting --\x3e\r\n    <include>\r\n      <uri>model://sun</uri>\r\n    </include>\r\n\r\n    \x3c!-- Custom ground with friction --\x3e\r\n    <model name="ground">\r\n      <static>true</static>\r\n      <link name="link">\r\n        <collision name="collision">\r\n          <geometry>\r\n            <plane>\r\n              <normal>0 0 1</normal>\r\n              <size>100 100</size>\r\n            </plane>\r\n          </geometry>\r\n          <surface>\r\n            <friction>\r\n              <ode>\r\n                <mu>1.0</mu>   \x3c!-- Friction coefficient --\x3e\r\n                <mu2>1.0</mu2>\r\n              </ode>\r\n            </friction>\r\n          </surface>\r\n        </collision>\r\n        <visual name="visual">\r\n          <geometry>\r\n            <plane>\r\n              <normal>0 0 1</normal>\r\n              <size>100 100</size>\r\n            </plane>\r\n          </geometry>\r\n          <material>\r\n            <ambient>0.8 0.8 0.8 1</ambient>\r\n            <diffuse>0.8 0.8 0.8 1</diffuse>\r\n          </material>\r\n        </visual>\r\n      </link>\r\n    </model>\r\n\r\n  </world>\r\n</sdf>\n'})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Code Explanation"}),":"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Lines 6-11"}),": Physics configuration"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"max_step_size"}),": Integration timestep (1ms for humanoid stability)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"real_time_factor"}),": 1 = real-time, >1 = faster, <1 = slower"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"real_time_update_rate"}),": 1000 Hz update rate"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"gravity"}),": Standard Earth gravity (9.81 m/s\xb2)"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Lines 14-21"}),": Built-in models"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Gazebo includes common models (ground, sun, obstacles)"}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"<include>"})," imports from Gazebo model database"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Lines 33-38"}),": Surface friction"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"mu"})," and ",(0,s.jsx)(e.code,{children:"mu2"}),": Friction coefficients (1.0 = concrete-like)"]}),"\n",(0,s.jsx)(e.li,{children:"Critical for humanoid foot-ground contact"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Launching the World"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Method 1: Direct launch\r\ngazebo simple_world.world\r\n\r\n# Method 2: With ROS 2\r\nros2 launch gazebo_ros gazebo.launch.py world:=simple_world.world\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Expected Output"}),": Gazebo opens with a gray ground plane and sunlight."]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"section-3-spawning-humanoid-robots",children:"Section 3: Spawning Humanoid Robots"}),"\n",(0,s.jsx)(e.p,{children:"Now let's spawn the URDF humanoid we created in Module 1 into our Gazebo world."}),"\n",(0,s.jsx)(e.h3,{id:"subsection-31-urdf-to-gazebo",children:"Subsection 3.1: URDF to Gazebo"}),"\n",(0,s.jsxs)(e.p,{children:["To use URDF in Gazebo, add ",(0,s.jsx)(e.strong,{children:"Gazebo-specific"})," tags for:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Collision properties"}),": Friction, restitution (bounce)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Visual materials"}),": Colors that Gazebo recognizes"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Sensor plugins"}),": Camera, IMU, LiDAR"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Actuator plugins"}),": Joint controllers"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"example-gazebo-enhanced-urdf",children:"Example: Gazebo-Enhanced URDF"}),"\n",(0,s.jsxs)(e.p,{children:["Add these tags to your ",(0,s.jsx)(e.code,{children:"humanoid_full.urdf"})," from Module 1:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Inside <robot> tag, after link/joint definitions --\x3e\r\n\r\n\x3c!-- Gazebo material for each link --\x3e\r\n<gazebo reference="base_link">\r\n  <material>Gazebo/Blue</material>\r\n  <mu1>1.0</mu1>  \x3c!-- Friction coefficient 1 --\x3e\r\n  <mu2>1.0</mu2>  \x3c!-- Friction coefficient 2 --\x3e\r\n</gazebo>\r\n\r\n<gazebo reference="left_foot">\r\n  <material>Gazebo/Black</material>\r\n  <mu1>1.5</mu1>  \x3c!-- High friction for foot --\x3e\r\n  <mu2>1.5</mu2>\r\n  <kp>1000000.0</kp>  \x3c!-- Contact stiffness --\x3e\r\n  <kd>100.0</kd>      \x3c!-- Contact damping --\x3e\r\n</gazebo>\r\n\r\n\x3c!-- Repeat for each link --\x3e\r\n\r\n\x3c!-- ROS 2 Control plugin --\x3e\r\n<gazebo>\r\n  <plugin filename="libgazebo_ros2_control.so" name="gazebo_ros2_control">\r\n    <parameters>$(find my_robot_description)/config/controllers.yaml</parameters>\r\n  </plugin>\r\n</gazebo>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"subsection-32-spawning-with-ros-2",children:"Subsection 3.2: Spawning with ROS 2"}),"\n",(0,s.jsx)(e.p,{children:"Create a launch file to spawn the humanoid:"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Code"})," (",(0,s.jsx)(e.code,{children:"spawn_humanoid.launch.py"}),"):"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\"\"\"\r\nLaunch file to spawn humanoid robot in Gazebo.\r\n\r\nUsage:\r\n    ros2 launch my_robot_bringup spawn_humanoid.launch.py\r\n\"\"\"\r\n\r\nimport os\r\nfrom ament_index_python.packages import get_package_share_directory\r\nfrom launch import LaunchDescription\r\nfrom launch.actions import ExecuteProcess, IncludeLaunchDescription\r\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\r\nfrom launch_ros.actions import Node\r\n\r\ndef generate_launch_description():\r\n    # Get package directories\r\n    gazebo_ros_dir = get_package_share_directory('gazebo_ros')\r\n    robot_description_dir = get_package_share_directory('my_robot_description')\r\n\r\n    # Path to URDF file\r\n    urdf_file = os.path.join(robot_description_dir, 'urdf', 'humanoid_full.urdf')\r\n\r\n    # Read URDF content\r\n    with open(urdf_file, 'r') as f:\r\n        robot_description = f.read()\r\n\r\n    # Launch Gazebo world\r\n    gazebo = IncludeLaunchDescription(\r\n        PythonLaunchDescriptionSource(\r\n            os.path.join(gazebo_ros_dir, 'launch', 'gazebo.launch.py')\r\n        ),\r\n        launch_arguments={'world': 'simple_world.world'}.items()\r\n    )\r\n\r\n    # Spawn robot\r\n    spawn_robot = Node(\r\n        package='gazebo_ros',\r\n        executable='spawn_entity.py',\r\n        arguments=[\r\n            '-entity', 'humanoid',\r\n            '-topic', '/robot_description',\r\n            '-x', '0.0',\r\n            '-y', '0.0',\r\n            '-z', '1.0',  # Spawn 1m above ground\r\n        ],\r\n        output='screen'\r\n    )\r\n\r\n    # Robot state publisher\r\n    robot_state_publisher = Node(\r\n        package='robot_state_publisher',\r\n        executable='robot_state_publisher',\r\n        parameters=[{'robot_description': robot_description}],\r\n        output='screen'\r\n    )\r\n\r\n    return LaunchDescription([\r\n        gazebo,\r\n        robot_state_publisher,\r\n        spawn_robot,\r\n    ])\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Code Explanation"}),":"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Lines 27-33"}),": Launch Gazebo with custom world"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Lines 36-46"}),": Spawn robot entity","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"-entity"}),": Name in simulation"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"-topic"}),": Where to read URDF from"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"-x"}),", ",(0,s.jsx)(e.code,{children:"-y"}),", ",(0,s.jsx)(e.code,{children:"-z"}),": Initial position"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Lines 49-54"}),": Publish robot state to TF tree"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Running the Launch File"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Source ROS 2 environment\r\nsource /opt/ros/humble/setup.bash\r\n\r\n# Launch\r\nros2 launch my_robot_bringup spawn_humanoid.launch.py\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Expected Output"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Gazebo opens with your humanoid standing at (0, 0, 1)"}),"\n",(0,s.jsx)(e.li,{children:"Robot appears in 3D viewer"}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"/robot_description"})," topic published"]}),"\n",(0,s.jsx)(e.li,{children:"TF frames available for all links"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Troubleshooting"}),":"]}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Issue"}),(0,s.jsx)(e.th,{children:"Solution"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Robot falls through ground"}),(0,s.jsxs)(e.td,{children:["Increase ",(0,s.jsx)(e.code,{children:"<kp>"})," (contact stiffness) in foot collision"]})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Robot explodes/jitters"}),(0,s.jsx)(e.td,{children:"Reduce timestep to 0.0001, increase link masses"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"No robot appears"}),(0,s.jsxs)(e.td,{children:["Check URDF path, verify ",(0,s.jsx)(e.code,{children:"robot_description"})," topic with ",(0,s.jsx)(e.code,{children:"ros2 topic echo"})]})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Joints don't move"}),(0,s.jsx)(e.td,{children:"Add ros2_control plugin and controllers"})]})]})]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"section-4-physics-configuration",children:"Section 4: Physics Configuration"}),"\n",(0,s.jsx)(e.p,{children:"Gazebo's physics engine determines how realistically your humanoid behaves."}),"\n",(0,s.jsx)(e.h3,{id:"subsection-41-physics-engine-options",children:"Subsection 4.1: Physics Engine Options"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<physics type="ode">  \x3c!-- Or: bullet, dart, simbody --\x3e\r\n  \x3c!-- Solver settings --\x3e\r\n  <max_step_size>0.001</max_step_size>         \x3c!-- 1ms timestep --\x3e\r\n  <real_time_factor>1.0</real_time_factor>      \x3c!-- 1x real-time --\x3e\r\n  <real_time_update_rate>1000</real_time_rate> \x3c!-- 1000 Hz --\x3e\r\n\r\n  \x3c!-- ODE-specific (most common) --\x3e\r\n  <ode>\r\n    <solver>\r\n      <type>quick</type>           \x3c!-- quick | world --\x3e\r\n      <iters>50</iters>            \x3c!-- Solver iterations --\x3e\r\n      <sor>1.3</sor>               \x3c!-- Successive over-relaxation --\x3e\r\n    </solver>\r\n    <constraints>\r\n      <cfm>0.0</cfm>               \x3c!-- Constraint force mixing --\x3e\r\n      <erp>0.2</erp>               \x3c!-- Error reduction parameter --\x3e\r\n      <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\r\n      <contact_surface_layer>0.001</contact_surface_layer>\r\n    </constraints>\r\n  </ode>\r\n\r\n  \x3c!-- Gravity (can be modified at runtime) --\x3e\r\n  <gravity>0 0 -9.81</gravity>\r\n</physics>\n'})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Key Parameters for Humanoids"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"max_step_size"}),": 0.001 (1ms) for stability, 0.0001 for high-precision"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"iters"}),": 50-200 for complex contact scenarios (feet on ground)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"cfm"}),": 0 for rigid, >0 for compliant joints"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"contact_surface_layer"}),": Small values (0.001) for precise contact"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"subsection-42-contact-surface-properties",children:"Subsection 4.2: Contact Surface Properties"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Per-link surface properties --\x3e\r\n<gazebo reference="left_foot">\r\n  <mu1>1.5</mu1>              \x3c!-- Friction coefficient (lateral) --\x3e\r\n  <mu2>1.5</mu2>              \x3c!-- Friction coefficient (longitudinal) --\x3e\r\n  <kp>1000000.0</kp>          \x3c!-- Contact stiffness (N/m) --\x3e\r\n  <kd>100.0</kd>              \x3c!-- Contact damping (N\u22c5s/m) --\x3e\r\n  <minDepth>0.001</minDepth>  \x3c!-- Minimum penetration before contact --\x3e\r\n  <maxVel>0.1</maxVel>        \x3c!-- Maximum contact correction velocity --\x3e\r\n</gazebo>\n'})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Material Friction Values"})," (Reference):"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Ice: 0.05"}),"\n",(0,s.jsx)(e.li,{children:"Wood on wood: 0.4"}),"\n",(0,s.jsx)(e.li,{children:"Rubber on concrete: 0.9-1.5 \u2713 (Humanoid foot)"}),"\n",(0,s.jsx)(e.li,{children:"Steel on steel: 0.8"}),"\n"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"section-5-gazebo-gui-tools",children:"Section 5: Gazebo GUI Tools"}),"\n",(0,s.jsx)(e.p,{children:"The Gazebo GUI provides essential debugging tools."}),"\n",(0,s.jsx)(e.h3,{id:"subsection-51-view-menu-tools",children:"Subsection 5.1: View Menu Tools"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Wireframe Mode"}),": See collision geometries"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"View \u2192 Wireframe"}),"\n",(0,s.jsx)(e.li,{children:"Helps debug invisible collision boxes"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Transparent Mode"}),": See internal links"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"View \u2192 Transparent"}),"\n",(0,s.jsx)(e.li,{children:"Useful for multi-link robots"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Joints"}),": Visualize joint axes"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"View \u2192 Joints"}),"\n",(0,s.jsx)(e.li,{children:"Shows rotation/translation axes"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Center of Mass"}),": Display COM markers"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"View \u2192 Center of Mass"}),"\n",(0,s.jsx)(e.li,{children:"Critical for balance analysis"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Contacts"}),": Show contact points"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"View \u2192 Contacts"}),"\n",(0,s.jsx)(e.li,{children:"Verify foot-ground contact"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"subsection-52-useful-keyboard-shortcuts",children:"Subsection 5.2: Useful Keyboard Shortcuts"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Shortcut"}),(0,s.jsx)(e.th,{children:"Action"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Space"})}),(0,s.jsx)(e.td,{children:"Pause/unpause simulation"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Ctrl+R"})}),(0,s.jsx)(e.td,{children:"Reset world"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"T"})}),(0,s.jsx)(e.td,{children:"Toggle translation mode"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"R"})}),(0,s.jsx)(e.td,{children:"Toggle rotation mode"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"S"})}),(0,s.jsx)(e.td,{children:"Toggle scale mode"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Shift+Ctrl+T"})}),(0,s.jsx)(e.td,{children:"Show model tree"})]})]})]}),"\n",(0,s.jsx)(e.h3,{id:"subsection-53-inspection-tools",children:"Subsection 5.3: Inspection Tools"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:'# List all models in simulation\r\ngz model --list\r\n\r\n# Get model pose\r\ngz model -m humanoid -p\r\n\r\n# Set model pose\r\ngz model -m humanoid -x 1.0 -y 2.0 -z 1.0\r\n\r\n# Apply force to model\r\ngz model -m humanoid -f "10 0 0"\r\n\r\n# Get joint positions\r\nros2 topic echo /joint_states\n'})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"hands-on-project-humanoid-drop-test",children:"Hands-On Project: Humanoid Drop Test"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Goal"}),": Test your humanoid's contact physics by dropping it from height and analyzing impact forces."]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Duration"}),": 30 minutes"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"What You'll Learn"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Configure realistic contact physics"}),"\n",(0,s.jsx)(e.li,{children:"Measure impact forces"}),"\n",(0,s.jsx)(e.li,{children:"Tune damping for stable landing"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"step-1-create-drop-test-world",children:"Step 1: Create Drop Test World"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- drop_test.world --\x3e\r\n<sdf version="1.6">\r\n  <world name="drop_test">\r\n    <physics type="ode">\r\n      <max_step_size>0.0001</max_step_size>  \x3c!-- High precision --\x3e\r\n      <real_time_update_rate>10000</real_time_update_rate>\r\n      <gravity>0 0 -9.81</gravity>\r\n    </physics>\r\n\r\n    <include><uri>model://ground_plane</uri></include>\r\n    <include><uri>model://sun</uri></include>\r\n\r\n    \x3c!-- Soft landing pad --\x3e\r\n    <model name="landing_pad">\r\n      <static>true</static>\r\n      <link name="link">\r\n        <collision name="collision">\r\n          <geometry>\r\n            <box><size>2 2 0.1</size></box>\r\n          </geometry>\r\n          <surface>\r\n            <contact>\r\n              <ode>\r\n                <kp>10000</kp>   \x3c!-- Softer than ground --\x3e\r\n                <kd>100</kd>\r\n              </ode>\r\n            </contact>\r\n          </surface>\r\n        </collision>\r\n      </link>\r\n    </model>\r\n  </world>\r\n</sdf>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"step-2-launch-with-humanoid-at-2m-height",children:"Step 2: Launch with Humanoid at 2m Height"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Terminal 1: Launch Gazebo\r\nros2 launch gazebo_ros gazebo.launch.py world:=drop_test.world\r\n\r\n# Terminal 2: Spawn humanoid at height\r\nros2 run gazebo_ros spawn_entity.py -entity humanoid -file humanoid_full.urdf \\\r\n    -x 0 -y 0 -z 2.0\n"})}),"\n",(0,s.jsx)(e.h3,{id:"step-3-monitor-impact-forces",children:"Step 3: Monitor Impact Forces"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\"\"\"Monitor foot contact forces during drop test.\"\"\"\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom gazebo_msgs.msg import ContactsState\r\n\r\nclass ImpactMonitor(Node):\r\n    def __init__(self):\r\n        super().__init__('impact_monitor')\r\n        self.subscription = self.create_subscription(\r\n            ContactsState,\r\n            '/left_foot/contacts',\r\n            self.contact_callback,\r\n            10\r\n        )\r\n        self.max_force = 0.0\r\n\r\n    def contact_callback(self, msg):\r\n        if len(msg.states) > 0:\r\n            # Get total contact force\r\n            force = msg.states[0].total_wrench.force\r\n            force_magnitude = (force.x**2 + force.y**2 + force.z**2)**0.5\r\n\r\n            if force_magnitude > self.max_force:\r\n                self.max_force = force_magnitude\r\n                self.get_logger().info(f'Peak force: {self.max_force:.2f} N')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = ImpactMonitor()\r\n    rclpy.spin(node)\r\n    node.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Checkpoint"}),": Humanoid drops, lands on feet, and peak force is logged. If robot bounces excessively, increase kd (damping). If it sinks into ground, increase kp (stiffness)."]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"challenge-test-your-understanding",children:"Challenge: Test Your Understanding"}),"\n",(0,s.jsx)(e.p,{children:"Try these exercises to reinforce your learning:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Basic"}),": Create a world with obstacles (boxes, cylinders) for the humanoid to navigate."]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.em,{children:"Hint"}),": Use ",(0,s.jsx)(e.code,{children:"<model>"})," tags with ",(0,s.jsx)(e.code,{children:"<static>true</static>"})," for immovable objects."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Intermediate"}),": Modify physics parameters to simulate the Moon (gravity = 1.62 m/s\xb2)."]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.em,{children:"Hint"}),": Change ",(0,s.jsx)(e.code,{children:"<gravity>0 0 -1.62</gravity>"})," and observe walking behavior."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Advanced"}),": Add a slope (ramp) to the world and test humanoid stability on inclines."]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.em,{children:"Hint"}),": Rotate a plane link using ",(0,s.jsx)(e.code,{children:"<pose>0 0 0 0 0.1 0</pose>"})," (roll around X-axis)."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Solutions"}),": Test by running simulations and verifying robot behavior matches expectations."]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(e.p,{children:"In this chapter, you learned:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Gazebo architecture"}),": Server (physics), client (GUI), plugins (extensibility)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"World creation"}),": SDF format, physics settings, lighting, terrain"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Robot spawning"}),": Launch files, URDF integration, initial positioning"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Physics tuning"}),": Contact properties, friction, solver parameters for humanoids"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Debugging tools"}),": GUI overlays, command-line inspection, contact visualization"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Key Commands"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"gazebo world.world                              # Launch Gazebo with world\r\nros2 launch gazebo_ros gazebo.launch.py         # Launch with ROS 2\r\nros2 run gazebo_ros spawn_entity.py -file robot.urdf  # Spawn robot\r\ngz model --list                                 # List models\r\ngz model -m robot_name -p                       # Get model pose\r\nros2 topic list | grep gazebo                   # List Gazebo topics\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Core Concepts"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"SDF"}),": Simulation Description Format for worlds and models"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Physics Engine"}),": ODE, Bullet, or DART for rigid body dynamics"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Contact"}),": Interaction between colliding surfaces (friction, stiffness, damping)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Plugin"}),": Shared library extending Gazebo (sensors, controllers, logging)"]}),"\n"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,s.jsx)(e.p,{children:"Official Documentation:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"http://classic.gazebosim.org/",children:"Gazebo Classic Documentation"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"http://sdformat.org/",children:"SDF Format Specification"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://github.com/ros-simulation/gazebo_ros_pkgs",children:"ROS 2 Gazebo Integration"})}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Tutorials and Examples:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"http://classic.gazebosim.org/tutorials",children:"Gazebo Classic Tutorials"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://github.com/ros2/gazebo_ros2_control",children:"ROS 2 Gazebo Demos"})}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Physics References:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://www.ode.org/ode-latest-userguide.html",children:"ODE (Open Dynamics Engine) Manual"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://pybullet.org/wordpress/",children:"Bullet Physics Documentation"})}),"\n"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsx)(e.p,{children:"You're now ready to move on to the next chapter!"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Next Chapter"}),": ",(0,s.jsx)(e.a,{href:"/physical-ai-textbook/docs/module2-simulation/ch2-sensor-simulation",children:"Chapter 2.2: Sensor Simulation"})]}),"\n",(0,s.jsx)(e.p,{children:"In the next chapter, you'll learn how to add sensors (LiDAR, depth cameras, IMU) to your humanoid for perception\u2014simulating realistic sensor noise, ray tracing for LiDAR, and camera image generation."}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Optional Practice"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Create a world with stairs for the humanoid to climb"}),"\n",(0,s.jsx)(e.li,{children:"Add dynamic objects (rolling balls) for interaction testing"}),"\n",(0,s.jsx)(e.li,{children:"Experiment with different physics engines (ode vs. bullet)"}),"\n",(0,s.jsx)(e.li,{children:"Measure simulation performance (real-time factor) with complex scenes"}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>t,x:()=>l});var r=i(6540);const s={},o=r.createContext(s);function t(n){const e=r.useContext(o);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:t(n.components),r.createElement(o.Provider,{value:e},n.children)}}}]);